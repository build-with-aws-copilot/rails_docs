{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>In this ebook, I will show you how to build a Rails stack using Docker and AWS Copilot. By the end of this book, you will have:</p> <ol> <li>Webservers and workers (Sidekiq) running on ECS Fargate</li> <li>CI/CD pipeline on Github Actions</li> <li>Production and Staging environments on AWS</li> <li>A SSL/TLS certificate installed on the load balancer</li> <li>The webservers running under your domain</li> </ol> <p></p>"},{"location":"about_the_author/","title":"About the Author","text":"<p>Richard Chou is a Lead Developer at Ezy Raise, where he assists fundraisers in running successful online fundraising events. He has extensive experience in Ruby/Rails, and he is also a certified professional in AWS.</p> <p></p>"},{"location":"adding_postgres/","title":"Adding Postgres","text":"<p>Info</p> <p>Here I'm going to create Postgres with AWS UI. But of course you can use IaC tools such as Terraform, CDK...etc.</p>"},{"location":"adding_postgres/#create-postgres","title":"Create Postgres","text":"<p>Create a Postgres in staging and production accounts. </p>"},{"location":"adding_postgres/#add-environment-variables","title":"Add Environment Variables","text":"<pre><code>copilot secret init\nWhat would you like to name this secret? [? for help] RDS_HOSTNAME\nWhat is the value of secret REDIS_HOST in environment prod?\nWhat is the value of secret REDIS_HOST in environment staging?\n\ncopilot secret init\nWhat would you like to name this secret? [? for help] RDS_PORT\nWhat is the value of secret REDIS_HOST in environment prod?\nWhat is the value of secret REDIS_HOST in environment staging?\n\ncopilot secret init\nWhat would you like to name this secret? [? for help] RDS_DB_NAME\nWhat is the value of secret REDIS_HOST in environment prod?\nWhat is the value of secret REDIS_HOST in environment staging?\n\ncopilot secret init\nWhat would you like to name this secret? [? for help] RDS_USERNAME\nWhat is the value of secret REDIS_HOST in environment prod?\nWhat is the value of secret REDIS_HOST in environment staging?\n\ncopilot secret init\nWhat would you like to name this secret? [? for help] RDS_PASSWORD\nWhat is the value of secret REDIS_HOST in environment prod?\nWhat is the value of secret REDIS_HOST in environment staging?\n</code></pre>"},{"location":"adding_postgres/#security-group","title":"Security Group","text":"<p>Add ECS's security group to allowed inbound traffic, so ECS can talk to Postgres. </p>"},{"location":"adding_postgres/#update-database-config","title":"Update Database Config","text":"<p>Update <code>config/database.yml</code></p> <pre><code># SQLite. Versions 3.8.0 and up are supported.\n#   gem install sqlite3\n#\n#   Ensure the SQLite 3 gem is defined in your Gemfile\n#   gem \"sqlite3\"\n#\ndefault: &amp;default\n  adapter: postgresql\n  pool: &lt;%= ENV.fetch(\"RAILS_MAX_THREADS\") { 5 } %&gt;\n  timeout: 5000\n\ndevelopment:\n  &lt;&lt;: *default\n  database: rails70_development\n\n# Warning: The database defined as \"test\" will be erased and\n# re-generated from your development database when you run \"rake\".\n# Do not set this db to the same as development or production.\ntest:\n  &lt;&lt;: *default\n  database: rails70_test\n\nproduction:\n  &lt;&lt;: *default\n  database: &lt;%= ENV['RDS_DB_NAME'] %&gt;\n  username: &lt;%= ENV['RDS_USERNAME'] %&gt;\n  password: &lt;%= ENV['RDS_PASSWORD'] %&gt;\n  host: &lt;%= ENV['RDS_HOSTNAME'] %&gt;\n  port: &lt;%= ENV['RDS_PORT'] %&gt;\n</code></pre>"},{"location":"adding_postgres/#postgres-running-on-production","title":"Postgres Running on Production","text":""},{"location":"adding_redis/","title":"Adding Redis","text":"<p>Info</p> <p>Here I'm going to create a Redis server with AWS UI. But of course you can use IaC tools such as Terraform, CDK...etc.</p> <p>Create a Redis server.</p> <p>Single instance mode or with replica, but not the cluster.</p> <p></p>"},{"location":"adding_redis/#security-group","title":"Security Group","text":"<p>Allow ECS' security group to allowed inbound traffic, so webservers and wokers can talk to Redis.</p> <p></p> <p></p>"},{"location":"adding_redis/#redis-running-on-production","title":"Redis Running on Production","text":""},{"location":"adding_ssl_tls_certificate/","title":"Adding SSL/TLS Certificate","text":""},{"location":"adding_ssl_tls_certificate/#certificate-verification","title":"Certificate Verification","text":"<p>Request a new certificate on ACM </p> <p>Create a CNAME in your DNS settings</p> <p></p> <p>Your certificate will change from \"pending\" to \"issued\"</p>"},{"location":"adding_ssl_tls_certificate/#allow-https-traffic-to-alb","title":"Allow HTTPS traffic to ALB","text":"<p>Update security group of ALB (allow 443)</p> <p>Add listener 443 to ALB, attach the SSL/TLS certificate that you have created in previous step, and forward it to Target Group (not Default Group) </p> <p></p>"},{"location":"adding_ssl_tls_certificate/#redirect-http-to-https","title":"Redirect HTTP to HTTPS","text":"<p>Update 2 listener rules on port 80, redirect them to 443</p> <p></p>"},{"location":"adding_your_domain/","title":"Adding Your Domain","text":"<p>Create a CNAME in your DNS settings, point it to ALB </p> <p></p>"},{"location":"ci_cd/","title":"CI/CD on GitHub Actions","text":"<p>Place the following secrets in your GitHub settings. They are the credentials from <code>[copilot.application]</code> named profile.</p> <pre><code>key: AWS_ACCESS_KEY_ID_APP\nvalue: AKIUJFHFJDFKFUBHUE88\n\nkey: AWS_SECRET_ACCESS_KEY_APP\nvalue: +Wv3oDIUJSDHCNVBOLQKDIFUDIIIUDIKBK+vUmqc\n</code></pre>"},{"location":"ci_cd/#staging-deployment","title":"Staging Deployment","text":"<p>Create a file <code>./github/workflows/staging.yml</code></p> <pre><code>name: staging webserver deployment\n\non:\n  push:\n    branches: [ \"develop\" ]\n\njobs:\n  copilot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install copilot\n        run: |\n          mkdir -p $GITHUB_WORKSPACE/bin\n          # download copilot\n          curl -Lo copilot-linux https://github.com/aws/copilot-cli/releases/download/v1.27.0/copilot-linux &amp;&amp; \\\n          # make copilot bin executable\n          chmod +x copilot-linux &amp;&amp; \\\n          # move to path\n          mv copilot-linux $GITHUB_WORKSPACE/bin/copilot &amp;&amp; \\\n          # add to PATH\n          echo \"$GITHUB_WORKSPACE/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: staging deployment\n        run: copilot svc deploy --app rails70 --env staging --name webserver\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_TOOLS }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_TOOLS }}\n          AWS_REGION: us-west-2\n          DOCKER_BUILDKIT: 1\n</code></pre> <p>When you commit to <code>develop</code>, GitHub will trigger the script and deploy your code to staging account.</p>"},{"location":"ci_cd/#production-deployment","title":"Production Deployment","text":"<p>Create a file <code>./github/workflows/prod.yml</code></p> <pre><code>name: production webserver deployment\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  copilot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install copilot\n        run: |\n          mkdir -p $GITHUB_WORKSPACE/bin\n          # download copilot\n          curl -Lo copilot-linux https://github.com/aws/copilot-cli/releases/download/v1.27.0/copilot-linux &amp;&amp; \\\n          # make copilot bin executable\n          chmod +x copilot-linux &amp;&amp; \\\n          # move to path\n          mv copilot-linux $GITHUB_WORKSPACE/bin/copilot &amp;&amp; \\\n          # add to PATH\n          echo \"$GITHUB_WORKSPACE/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: prod deployment\n        run: copilot svc deploy --app rails70 --env production --name webserver\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_TOOLS }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_TOOLS }}\n          AWS_REGION: us-west-2\n          DOCKER_BUILDKIT: 1\n</code></pre> <p>When you commit to <code>main</code>, GitHub will trigger the script and deploy your code to prod account.</p>"},{"location":"ci_cd/#deployment-on-github-actions","title":"Deployment on GitHub Actions","text":""},{"location":"complete_stack/","title":"Complete Stack","text":"<p>After deployment, you will see webservers and workers have been deployed to ECS:</p> <p> </p> ECS services (webservers and workers) <p> </p> ECS tasks"},{"location":"creating_dockerfile/","title":"Creating Dockerfile","text":""},{"location":"creating_dockerfile/#create-a-new-rails-app","title":"Create a new Rails app","text":"<p>Run</p> <pre><code>rails new rails70\n</code></pre> <p>Add <code>dockerfile-rails</code> to <code>Gemfile</code></p> <pre><code>gem \"dockerfile-rails\", \"~&gt; 1.2.5\", :group =&gt; :development\n</code></pre> <p>We will run docker on x86-64 linux on ECS, so we need to add platform support for x86-64</p> <pre><code>bundle lock --add-platform x86_64-linux\n</code></pre> <p>Run <code>bundle install</code></p>"},{"location":"creating_dockerfile/#generate-dockerfile","title":"Generate Dockerfile","text":"<p><code>dockerfile-rails</code> is a Rails generator to produce Dockerfiles.</p> <p>Run</p> <pre><code>bin/rails generate dockerfile\n</code></pre> <p>to generate a Dockerfile:</p> <p>Info</p> <p>This Dockerfile uses <code>--link</code>, so the syntax has to be at least 1.4 (line 1).</p> <p>Info</p> <p><code>dockerfile-rails</code> supports many different parameters, I encourage you to check out its demo and the supported parameters.</p>"},{"location":"creating_dockerfile/#test-dockerfile-on-local","title":"Test Dockerfile on local","text":"<p>Info</p> <p>You need to have Docker installed on your local</p> <p>Add a default route to <code>routes.rb</code></p> <pre><code>root \"rails/welcome#index\"\n</code></pre> <p>Run the following command</p> <pre><code>docker buildx build . -t rails70\ndocker run -p 3000:3000 -e RAILS_MASTER_KEY=$(cat config/master.key) --rm rails70\n</code></pre> <p>Open up your browser and go to <code>localhost:3000</code>  Contgratulations, you have successfully run Rails container on your local. Next we will deploy the same image to AWS.</p> <p>Info</p> <p>At this moment, we only have a Rails skeleton app, there is no caching layer (Redis) or persistence layer (Postgres). We will make sure the skeleton app runs ok on AWS, and then add those layers.</p>"},{"location":"database_migration/","title":"Database Migration","text":"<p>The Dockerfile has this line</p> <pre><code>ENTRYPOINT [\"/rails/bin/docker-entrypoint\"]\n</code></pre> <p>If we look at the content of <code>docker-entrypoint</code></p> <pre><code>#!/bin/bash -e\n\n# If running the rails server then create or migrate existing database\nif [ \"${*}\" == \"./bin/rails server\" ]; then\n  ./bin/rails db:prepare\nfi\n\nexec \"${@}\"\n</code></pre> <p>That means when a server starts, migration will be run. If there are multiple servers, migration will be run multiple times. This is not ideal, we only want migration to be run once during a deployment.</p> <p>Remove this line from <code>Dockerfile</code> and <code>Dockerfile.sidekiq</code></p> <pre><code>ENTRYPOINT [\"/rails/bin/docker-entrypoint\"]\n</code></pre> <p>Add migration to GitHub Actions:</p> <pre><code>name: production webserver deployment\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  copilot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install copilot\n        run: |\n          mkdir -p $GITHUB_WORKSPACE/bin\n          # download copilot\n          curl -Lo copilot-linux https://github.com/aws/copilot-cli/releases/download/v1.27.0/copilot-linux &amp;&amp; \\\n          # make copilot bin executable\n          chmod +x copilot-linux &amp;&amp; \\\n          # move to path\n          mv copilot-linux $GITHUB_WORKSPACE/bin/copilot &amp;&amp; \\\n          # add to PATH\n          echo \"$GITHUB_WORKSPACE/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: prod webserver deployment\n        run: copilot svc deploy -n webserver -e prod -a rails70\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_TOOLS }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_TOOLS }}\n          AWS_REGION: us-west-2\n          DOCKER_BUILDKIT: 1\n\n      - name: prod migration\n        run: copilot svc exec -n webserver -e prod -a rails70 -c './bin/rails db:prepare RAILS_ENV=production'\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_TOOLS }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_TOOLS }}\n          AWS_REGION: us-west-2\n          DOCKER_BUILDKIT: 1\n</code></pre> <p>Info</p> <p>The migration is run after code has been deployed. If you place the migration before the deployment, since the code hasn't been deployed, nothing will be run.</p>"},{"location":"database_migration/#db-migration-running-in-github-actions","title":"DB Migration Running in GitHub Actions","text":""},{"location":"deploying_webserver_to_aws/","title":"Deploying Webserver to AWS","text":"<p>Let's recap what we have done so far. We have</p> <ol> <li>created Copilot app in AWS application account</li> <li>created production environment in AWS production account</li> <li>created staging environment in AWS staging account</li> <li>created webserver and worker manifests</li> </ol> <p>We're ready to deploy our Rails app to AWS.</p>"},{"location":"deploying_webserver_to_aws/#configure-rails","title":"Configure Rails","text":"<p>Add following to <code>application.rb</code>. AWS Load Balancer will generate a domain, but we don't know what it is yet. So we will allow any domain for now.</p> <pre><code>config.hosts = [\n  /.*/,\n]\n</code></pre>"},{"location":"deploying_webserver_to_aws/#add-environment-variables-to-aws","title":"Add Environment Variables to AWS","text":"<pre><code>copilot secret init\nWhat would you like to name this secret? [? for help] RAILS_MASTER_KEY\nWhat is the value of secret RAILS_MASTER_KEY in environment prod? # paste the master key from config/master.key to here\nWhat is the value of secret RAILS_MASTER_KEY in environment staging? # paste the master key from config/master.key to here\n</code></pre> <p>After secrets are added, add following to webserver manifests so the containers can use these environment variables.</p> <p>webserver/manifest</p> <pre><code>secrets:\n    RAILS_MASTER_KEY: /copilot/${COPILOT_APPLICATION_NAME}/${COPILOT_ENVIRONMENT_NAME}/secrets/RAILS_MASTER_KEY\n</code></pre>"},{"location":"deploying_webserver_to_aws/#deploy-webserver","title":"Deploy Webserver","text":"<p>Now we're ready to deploy webserver to AWS. Run</p> <pre><code>copilot svc deploy --app rails70 --env staging --name webserver # push to staging\ncopilot svc deploy --app rails70 --env prod --name webserver # push to production\n</code></pre> <p>Info</p> <p>You need to have Docker running on your local. Copilot will build a docker image, deploy it to ECR and run the image in ECS.</p> <p>Info</p> <p>We only need to build the image manually for the first time. Later we will move the building/deployment process to Github Actions.</p> <p> </p> A Successful Deployment <p>You will see an URL at the end of the deployment. That's the URL of the Load Balancer which Copilot has provisioned for us. Open up the URL: </p> <p>Congratulations, you have deployed your first container to AWS \ud83c\udf89</p> <p>Info</p> <p>When Copilot is deploying the services, you can check the log on AWS to see if there's any error </p> <p>If there is, don't waste time waiting for Copilot to return error. Go to CloudFormation, delete the task, fix the error and redeploy (<code>copilot svc deploy</code>).  </p>"},{"location":"deploying_worker_to_aws/","title":"Deploying Worker to AWS","text":"<p>Info</p> <p>By default, backend services will be launched in public subnet, and therefore have internet access. You can also launch backend services in private subnet, and use NAT gateway to access the internet.</p>"},{"location":"deploying_worker_to_aws/#add-environment-variables-to-aws","title":"Add Environment Variables to AWS","text":"<p>Create environment variables for redis, so sidekiq and connect it to process jobs:</p> <pre><code>copilot secret init\nWhat would you like to name this secret? [? for help] REDIS_HOST\nWhat is the value of secret REDIS_HOST in environment prod?\nWhat is the value of secret REDIS_HOST in environment staging?\n</code></pre> <pre><code>copilot secret init\nWhat would you like to name this secret? [? for help] REDIS_PORT\nWhat is the value of secret REDIS_PORT in environment prod?\nWhat is the value of secret REDIS_PORT in environment staging?\n</code></pre>"},{"location":"deploying_worker_to_aws/#setup-sidekiq","title":"Setup Sidekiq","text":"<p>config/routes.rb</p> <pre><code>require 'sidekiq/web'\n\nRails.application.routes.draw do\n  # Define your application routes per the DSL in https://guides.rubyonrails.org/routing.html\n\n  mount Sidekiq::Web =&gt; '/sidekiq'\n\n  resources :books, only: %i[index show]\n\n  resources :orders, only: %i[index show]\n\n  # Defines the root path route (\"/\")\n  # root \"articles#index\"\n  root \"rails/welcome#index\"\nend\n</code></pre> <p>config/initializers/sidekiq.rb</p> <pre><code>Sidekiq.configure_server do |config|\n  config.redis = { url: \"redis://#{ENV['REDIS_HOST']}:#{ENV['REDIS_PORT']}/0\" }\nend\n\nSidekiq.configure_client do |config|\n  config.redis = { url: \"redis://#{ENV['REDIS_HOST']}:#{ENV['REDIS_PORT']}/0\" }\nend\n</code></pre> <p>config/sidekiq_worker.yml</p> <pre><code># Jobs in low priority queue are not done until default queue is empty.\n# The order of the queues in this file is the order in which jobs are done.\n\n:concurrency: 5\n:queues:\n  - default\n  - low\n</code></pre> <p>config/environments/production.rb</p> <pre><code>config.active_job.queue_adapter = :sidekiq\n</code></pre>"},{"location":"deploying_worker_to_aws/#worker-service","title":"Worker Service","text":"<pre><code>export AWS_PROFILE=copilot.application\ncopilot svc init\nWhich service type best represents your service's architecture? Backend Service\nWhat do you want to name this service? worker\n</code></pre> <p>A manifest file will be generated under <code>copilot/worker/manifest.yml</code>.</p> <p>We can reuse the Dockerfile but override the <code>command</code>. So when the container starts, it will be running sidekiq, rather than web server:</p> <p><code>command: [\"bundle\", \"exec\", \"sidekiq\", \"-t\", \"15\", \"-C\", \"/rails/config/sidekiq_worker.yml\"]</code></p> <p>copilot/worker/manifest.yml</p> <pre><code># The manifest for the \"worker\" service.\n# Read the full specification for the \"Backend Service\" type at:\n#  https://aws.github.io/copilot-cli/docs/manifest/backend-service/\n\n# Your service name will be used in naming your resources like log groups, ECS services, etc.\nname: worker\ntype: Backend Service\n\n# Your service is reachable at \"http://worker.${COPILOT_SERVICE_DISCOVERY_ENDPOINT}:3000\" but is not public.\n\n# Configuration for your containers and service.\nimage:\n  port: 3000\n  build:\n    dockerfile: /Dockerfile\n    args:\n      AWS_S3_ACCESS_KEY_ID: ${AWS_S3_ACCESS_KEY_ID}\n      AWS_S3_SECRET_ACCESS_KEY: ${AWS_S3_SECRET_ACCESS_KEY}\n      S3_BUCKET_NAME: ${S3_BUCKET_NAME}\n      AWS_S3_REGION: ${AWS_S3_REGION}\n      CLOUDFRONT_ENDPOINT: ${CLOUDFRONT_ENDPOINT}\n      APPLE_PEM_PATH: ${APPLE_PEM_PATH}\n      APPLE_TEAM_ID: ${APPLE_TEAM_ID}\n      APPLE_KEY_ID: ${APPLE_KEY_ID}\n      REDIS_HOST: ${REDIS_HOST}\n      REDIS_PORT: ${REDIS_PORT}\n      AWS_REGION: ${AWS_REGION}\n      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}\n      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}\n      AIRBRAKE_PROJECT_ID: ${AIRBRAKE_PROJECT_ID}\n      AIRBRAKE_PROJECT_KEY: ${AIRBRAKE_PROJECT_KEY}\n      T_AUTHENTICATION_SECRET: ${T_AUTHENTICATION_SECRET}\n\ncommand: [\"bundle\", \"exec\", \"sidekiq\", \"-t\", \"15\", \"-C\", \"/rails/config/sidekiq_worker.yml\"]\ncpu: 1024       # Number of CPU units for the task.\nmemory: 2048    # Amount of memory in MiB used by the task.\nplatform: linux/x86_64     # See https://aws.github.io/copilot-cli/docs/manifest/backend-service/#platform\ncount: 1       # Number of tasks that should be running in your service.\nexec: true     # Enable running commands in your container.\nnetwork:\n  connect: true # Enable Service Connect for intra-environment traffic between services.\n\nsecrets:\n  REDIS_HOST: /copilot/${COPILOT_APPLICATION_NAME}/${COPILOT_ENVIRONMENT_NAME}/secrets/REDIS_HOST\n  REDIS_PORT: /copilot/${COPILOT_APPLICATION_NAME}/${COPILOT_ENVIRONMENT_NAME}/secrets/REDIS_PORT\n</code></pre>"},{"location":"deploying_worker_to_aws/#deploy-worker","title":"Deploy Worker","text":"<p>Now we're ready to deploy worker to AWS. Run</p> <pre><code>copilot svc deploy --app rails70 --env staging --name worker # push to staging\ncopilot svc deploy --app rails70 --env prod --name worker # push to production\n</code></pre>"},{"location":"deploying_worker_to_aws/#move-deployment-to-github-actions","title":"Move Deployment to GitHub Actions","text":""},{"location":"deploying_worker_to_aws/#staging-environment","title":"Staging Environment","text":"<p>Add following to <code>./github/workflows/staging.yml</code></p> <pre><code>name: staging worker deployment\n\non:\n  push:\n    branches: [ \"develop\" ]\n\njobs:\n  copilot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install copilot\n        run: |\n          mkdir -p $GITHUB_WORKSPACE/bin\n          # download copilot\n          curl -Lo copilot-linux https://github.com/aws/copilot-cli/releases/download/v1.27.0/copilot-linux &amp;&amp; \\\n          # make copilot bin executable\n          chmod +x copilot-linux &amp;&amp; \\\n          # move to path\n          mv copilot-linux $GITHUB_WORKSPACE/bin/copilot &amp;&amp; \\\n          # add to PATH\n          echo \"$GITHUB_WORKSPACE/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: prod worker deployment\n        run: copilot svc deploy -n worker -e staging -a rails70\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_TOOLS }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_TOOLS }}\n          AWS_REGION: us-west-2\n          DOCKER_BUILDKIT: 1\n</code></pre>"},{"location":"deploying_worker_to_aws/#production-deployment","title":"Production Deployment","text":"<p>Add following <code>./github/workflows/prod.yml</code></p> <pre><code>name: production worker deployment\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  copilot:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Install copilot\n        run: |\n          mkdir -p $GITHUB_WORKSPACE/bin\n          # download copilot\n          curl -Lo copilot-linux https://github.com/aws/copilot-cli/releases/download/v1.27.0/copilot-linux &amp;&amp; \\\n          # make copilot bin executable\n          chmod +x copilot-linux &amp;&amp; \\\n          # move to path\n          mv copilot-linux $GITHUB_WORKSPACE/bin/copilot &amp;&amp; \\\n          # add to PATH\n          echo \"$GITHUB_WORKSPACE/bin\" &gt;&gt; $GITHUB_PATH\n\n      - name: prod worker deployment\n        run: copilot svc deploy -n worker -e prod -a rails70\n        env:\n          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID_TOOLS }}\n          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY_TOOLS }}\n          AWS_REGION: us-west-2\n          DOCKER_BUILDKIT: 1\n</code></pre>"},{"location":"deploying_worker_to_aws/#sidekiq-running-on-production","title":"Sidekiq Running on Production","text":""},{"location":"ecs_graceful_shutdown/","title":"ECS Graceful Shutdown","text":"<p>When deploying to ECS, ECS will receive <code>SIGTERM</code>, it is a signal asking containers to get ready to be terminated. Default wait time is 30 seconds. After 30 seconds, the containers will receive <code>SIGKILL</code> and the containers will be stopped. If our Sidekiq takes 40 seconds on average to process jobs, we should extend the wait time a bit longer so Sidekiq can finish processing jobs without being interrupted.</p> <p>The default wait time <code>stopTimeout</code> can be overridden in Copilot. We will extend wait time to 50 seconds:</p> <p>Run</p> <pre><code>copilot svc override\n</code></pre> <p>This will generate the following files:</p> <pre><code>copilot/webserver/overrides/cfn.patches.yml\ncopilot/worker/overrides/cfn.patches.yml\n</code></pre> <p>Add the following command to the yml</p> <pre><code>- op: add\n  path: /Resources/TaskDefinition/Properties/ContainerDefinitions/0/StopTimeout\n  value: 50\n</code></pre> <p>After next deployment, we can go to ECS tasks and verify that <code>stopTimeout</code> has been added: </p> <p>We will also pass <code>-t</code> parameter to worker containers. <code>-t</code> is the number of seconds Sidekiq is expected to finish processing jobs. If average job processing time is 40 seconds, we will pass <code>-t 40</code>:</p> <p>Dockerfile.sidekiq</p> <pre><code>CMD [\"bundle\", \"exec\", \"sidekiq\", \"-t\", \"40\", \"-C\", \"/rails/config/sidekiq_worker.yml\"]\n</code></pre>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#install-aws-copilot","title":"Install AWS Copilot","text":"<p>Please follow the official guide to install AWS Copilot.</p> <p>After installation, make sure you can run</p> <pre><code>copilot --version\n</code></pre> <p>and see the output</p> <pre><code>copilot version: v1.27.0\n</code></pre>"},{"location":"getting_started/#install-ruby-on-rails","title":"Install Ruby on Rails","text":"<p>Run</p> <pre><code>gem install rails\n</code></pre> <p>After installation, run</p> <pre><code>rails -v\n</code></pre> <p>and make sure you can see the output</p> <pre><code>Rails 7.0.4.3\n</code></pre>"},{"location":"passing_build_time_variables_to_dockerfile/","title":"Passing build time variables to Dockerfile","text":"<p>If you need to pass build time variables to Dockerfile, you can do the following:</p>"},{"location":"passing_build_time_variables_to_dockerfile/#in-manifestyml","title":"In manifest.yml","text":"<p>In manifest.yml, add an <code>args</code> section under <code>image</code>:</p> <pre><code>image:\n  # Docker build arguments. For additional overrides: https://aws.github.io/copilot-cli/docs/manifest/lb-web-service/#image-build\n  # Port exposed through your container to route traffic to it.\n  port: 3000\n  build:\n    dockerfile: /Dockerfile\n    args:\n      AWS_S3_ACCESS_KEY_ID: ${AWS_S3_ACCESS_KEY_ID}\n      AWS_S3_SECRET_ACCESS_KEY: ${AWS_S3_SECRET_ACCESS_KEY}\n      S3_BUCKET_NAME: ${S3_BUCKET_NAME}\n      AWS_S3_REGION: ${AWS_S3_REGION}\n      CLOUDFRONT_ENDPOINT: ${CLOUDFRONT_ENDPOINT}\n      APPLE_PEM_PATH: ${APPLE_PEM_PATH}\n      APPLE_TEAM_ID: ${APPLE_TEAM_ID}\n      APPLE_KEY_ID: ${APPLE_KEY_ID}\n      REDIS_HOST: ${REDIS_HOST}\n      REDIS_PORT: ${REDIS_PORT}\n      AWS_REGION: ${AWS_REGION}\n      AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}\n      AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}\n      AIRBRAKE_PROJECT_ID: ${AIRBRAKE_PROJECT_ID}\n      AIRBRAKE_PROJECT_KEY: ${AIRBRAKE_PROJECT_KEY}\n      T_AUTHENTICATION_SECRET: ${T_AUTHENTICATION_SECRET}\n</code></pre> <p>These variables need to be provided by the environment in which the manifest is run. For example, we build docker image in CICD, so our CICD needs to provide these values.</p> <p>In Semaphore, we can provide these values in secrets:</p> <p></p>"},{"location":"passing_build_time_variables_to_dockerfile/#in-dockerfile","title":"In Dockerfile","text":"<p>Once the variables are added to manifest, they will be passed on to Docker when building image. We can use these variables in Dockerfile:</p> <pre><code>ARG AWS_S3_ACCESS_KEY_ID=$AWS_S3_ACCESS_KEY_ID\nARG AWS_S3_SECRET_ACCESS_KEY=$AWS_S3_SECRET_ACCESS_KEY\nARG S3_BUCKET_NAME=$S3_BUCKET_NAME\nARG AWS_S3_REGION=$AWS_S3_REGION\nARG CLOUDFRONT_ENDPOINT=$CLOUDFRONT_ENDPOINT\nARG APPLE_PEM_PATH=$APPLE_PEM_PATH\nARG APPLE_TEAM_ID=$APPLE_TEAM_ID\nARG APPLE_KEY_ID=$APPLE_KEY_ID\nARG REDIS_HOST=$REDIS_HOST\nARG REDIS_PORT=$REDIS_PORT\nARG AWS_REGION=$AWS_REGION\nARG AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID\nARG AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY\nARG AIRBRAKE_PROJECT_ID=$AIRBRAKE_PROJECT_ID\nARG AIRBRAKE_PROJECT_KEY=$AIRBRAKE_PROJECT_KEY\nARG T_AUTHENTICATION_SECRET=$T_AUTHENTICATION_SECRET\n</code></pre>"},{"location":"provisioning_infrastructure/","title":"Provisioning Infrastructure on AWS","text":"<p>We will create 3 accounts on AWS</p> <ol> <li>Application account: our Rails app will be initialised in this account. Docker images will be pushed to this account (Elastic Container Registry)</li> <li>Staging account: for Rails staging environment</li> <li>Production account: for Rails production environment</li> </ol>"},{"location":"provisioning_infrastructure/#create-application-account","title":"Create Application Account","text":"<p>After application account is created, create an IAM user with Administrator Access. Console access can be disabled.</p>"},{"location":"provisioning_infrastructure/#create-staging-account","title":"Create Staging Account","text":"<p>After staging account is created, create an IAM user with Administrator Access. Console access can be disabled.</p>"},{"location":"provisioning_infrastructure/#create-production-account","title":"Create Production Account","text":"<p>After production account is created, create an IAM user with Administrator Access. Console access can be disabled.</p> <p> </p> An exmaple of IAM user <p>Warning</p> <p>It is not a good practise to give IAM user administrator access; we should give it the least priviledge. But for now we will let Copilot do its thing, for example creating Docker repository and IAM roles. Once everything has setup, we can delete the IAM users in staging and production. As for the IAM user in application account, we can use Access Analyzer to give it the least priviledge.</p>"},{"location":"provisioning_infrastructure/#create-aws-named-profiles","title":"Create AWS Named Profiles","text":"<p>Now you've created 3 IAM users. Add their credentials to <code>~/.aws/credentials</code> and <code>~/.aws/config</code> on your local</p> <p>~/.aws/credentials</p> <pre><code>[copilot.application]\naws_access_key_id=AKIUJFHFJDFKFUBHUE88\naws_secret_access_key=+Wv3oDIUJSDHCNVBOLQKDIFUDIIIUDIKBK+vUmqc\n\n[copilot.staging]\naws_access_key_id=AKLKMDJCHUUDHIDIUE67\naws_secret_access_key=eUdT8KIMDJFIOUJSHEHWEJQAZSDSEJFJFMFbyUrl\n\n[copilot.prod]\naws_access_key_id=AKIJUYHNBGTRFVBVC904\naws_secret_access_key=oWzVIUEURHFDKDJFKUHXBCNVJFJIIFKDFIUxxfqj\n</code></pre> <p>Info</p> <p>These are not real credentials</p> <p>~/.aws/config</p> <pre><code>[profile copilot.application]\nregion=us-west-2\n\n[profile copilot.staging]\nregion=us-west-2\n\n[profile copilot.prod]\nregion=us-west-2\n</code></pre>"},{"location":"provisioning_infrastructure/#create-copilot-app","title":"Create Copilot App","text":"<p>Earlier this page, we mentioned that our app will be initialized in application account. Let's initialize the app now.</p> <p>Export the application profile</p> <pre><code>export AWS_PROFILE=copilot.application\n</code></pre> <p>Initialize the app. We will name our app <code>rails70</code></p> <pre><code>copilot app init rails70\n</code></pre> <p></p> <p>After initialisation, run</p> <pre><code>copilot app ls\n</code></pre> <p>It should output</p> <pre><code>rails70\n</code></pre>"},{"location":"provisioning_infrastructure/#create-environments","title":"Create Environments","text":""},{"location":"provisioning_infrastructure/#staging-environment","title":"Staging Environment","text":"<p>Export the staging profile, and create the staging env</p> <pre><code>export AWS_PROFILE=copilot.staging\ncopilot env init\ncopilot env deploy --name staging\n</code></pre> <p></p>"},{"location":"provisioning_infrastructure/#production-environment","title":"Production Environment","text":"<p>Export the production profile, and create the production env</p> <pre><code>export AWS_PROFILE=copilot.prod\ncopilot env init\ncopilot env deploy --name prod\n</code></pre> <p></p> <p>After creating staging and production, run</p> <pre><code>copilot env ls\n</code></pre> <p>it should return</p> <pre><code>prod\nstaging\n</code></pre>"},{"location":"provisioning_infrastructure/#create-ecs-services","title":"Create ECS Services","text":"<p>Now we have created production and staging environments. We're going to create webserver and worker services, so they can run in ECS cluster.</p>"},{"location":"provisioning_infrastructure/#webserver-service","title":"Webserver Service","text":"<pre><code>export AWS_PROFILE=copilot.application\ncopilot svc init\nWhich service type best represents your service's architecture? Load Balanced Web Service\nWhat do you want to name this service? webserver\n</code></pre> <p>A manifest file will be generated under <code>copilot/webserver/manifest.yml</code></p>"},{"location":"rails_console/","title":"Rails Console","text":"<pre><code>export AWS_PROFILE=copilot.application\ncopilot svc exec --app rails70 --env prod --name webserver\n</code></pre>"}]}